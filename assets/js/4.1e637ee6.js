(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{267:function(v,_,r){v.exports=r.p+"assets/img/insertion.6e67d1c7.gif"},272:function(v,_,r){"use strict";r.r(_);var a=r(20),t=Object(a.a)({},function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"插入排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插入排序","aria-hidden":"true"}},[v._v("#")]),v._v(" 插入排序")]),v._v(" "),a("p",[v._v("说明"),a("strong",[v._v("插入排序")]),v._v("算法，证明该算法能正确的排序。")]),v._v(" "),a("h2",{attrs:{id:"算法说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法说明","aria-hidden":"true"}},[v._v("#")]),v._v(" 算法说明")]),v._v(" "),a("p",[v._v("插入排序是一种对于少量元素排序非常有效的排序算法，在日常生活中最常见的例子就是插入扑克牌，我们总是喜欢将某张扑克牌插入到已排序的扑克中。")]),v._v(" "),a("p",[a("img",{attrs:{src:r(267),alt:"插入排序"}})]),v._v(" "),a("h2",{attrs:{id:"算法证明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法证明","aria-hidden":"true"}},[v._v("#")]),v._v(" 算法证明")]),v._v(" "),a("blockquote",[a("p",[v._v("在"),a("code",[v._v("for")]),v._v("循环的每次迭代开始时，元素"),a("code",[v._v("array[0]~array[j-1]")]),v._v("始终是原数组的元素，且是一个排序好的子数组。以"),a("code",[v._v("[6,5,3,1,8,7,2,4]")]),v._v("为例，第一次循环默认"),a("code",[v._v("[6]")]),v._v("就是已经排序好的子数组，那么第二次循环"),a("code",[v._v("[5,6]")]),v._v("就是已经排序好的子数组，我们称这样的子数组为"),a("strong",[v._v("循环不变式")]),v._v("。")])]),v._v(" "),a("p",[a("strong",[v._v("循环不变式")]),v._v("可以帮助理解算法的正确性。关于"),a("strong",[v._v("循环不变式")]),v._v("必须证明三条性质：")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("初始化")]),v._v("：循环的第一次迭代之前，它为真。")]),v._v(" "),a("li",[a("strong",[v._v("保持")]),v._v("：循环的某次迭代之前它为真，那么下次迭代之前它仍然为真。")]),v._v(" "),a("li",[a("strong",[v._v("终止")]),v._v("：在循环终止时，不变式有助于证明算法的正确性。")])]),v._v(" "),a("p",[v._v("以"),a("code",[v._v("[6,5,3,1,8,7,2,4]")]),v._v("应用于插入排序证明该排序的正确性：")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("初始化")]),v._v("：当"),a("code",[v._v("j=1")]),v._v("时，"),a("strong",[v._v("循环不变式")]),v._v("为"),a("code",[v._v("array[0]~array[1-0]")]),v._v("，即第一次迭代之前的"),a("strong",[v._v("循环不变式")]),v._v("为原数组的"),a("code",[v._v("[6]")]),v._v("，在子数组只有一个元素的前提下，该元素默认可以归为已经排序好的元素，表明第一次迭代之前"),a("strong",[v._v("循环不变式")]),v._v("成立。")]),v._v(" "),a("li",[a("strong",[v._v("保持")]),v._v("：非形式化的，插入第"),a("code",[v._v("j")]),v._v("个元素，将"),a("code",[v._v("array[j-1]")]),v._v("、"),a("code",[v._v("array[j-2]")]),v._v("、"),a("code",[v._v("array[j-3]")]),v._v("等向右移动一个位置，直到找到"),a("code",[v._v("array[j]")]),v._v("的合适位置进行插入操作。首先，移动后的"),a("code",[v._v("arrary[0]~array[j]")]),v._v("仍然是移动前的元素"),a("code",[v._v("array[0]~array[j]")]),v._v("，只是元素的位置发生了变化。其次，此前"),a("code",[v._v("array[0]~array[j-1]")]),v._v("是一个排序好的数组，那么"),a("code",[v._v("array[0]~array[j]")]),v._v("仍然是一个排序好的数组。因此，下一次循环迭代增加"),a("code",[v._v("j")]),a("strong",[v._v("循环不变式")]),v._v("仍然保持不变。")]),v._v(" "),a("li",[a("strong",[v._v("终止")]),v._v("：在循环终止时，由"),a("code",[v._v("j<=array.length-1")]),v._v("可以确定终止条件为"),a("code",[v._v("j=array.length")]),v._v("，此时说明数组"),a("code",[v._v("array[0]~array[array.length-1]")]),v._v("是原来数组的所有元素，且已经按序排列，因此算法正确。")])])])},[],!1,null,null,null);_.default=t.exports}}]);