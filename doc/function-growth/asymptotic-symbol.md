## 渐进记号

渐进记号主要用于描述算法渐进运行时间，通常根据定义域为自然数集`N = {1,2,3,...}`的函数`T(n)`来定义。我们应该确保理解记号的精确含义，并在活用时不会误用它。接下来将介绍一些基本的渐进记号。

### 1. 渐进记号、函数与运行时间

我们知道了$\Theta$记号用于描述算法的最坏情况运行时间，例如插入排序的最坏情况运行时间为$\Theta(n^2)$，但是事实上我们计算出的最坏运行情况是函数$T(n) = an^2 + bn + c$，用$\Theta$记号进行表示省略了函数的一些细节。

使用渐进记号描述算法的运行时间需要清楚是哪种情况的运行时间，例如用$\Theta$记号表示算法的最坏情况运行时间。然而我们希望刻画任何输入的运行时间，而不仅仅是最坏情况的运行时间，因此需要使用其他记号来表示一些特定的情况。


### 2. $\Theta$记号

定义$\Theta$记号（表示为$f(n)$的集合）
$$ \Theta(g(n)) = \\{ f(n) : 存在常量c_1、c_2和n_0，使得对所有的n \ge n_0，有0 \le c_1g(n) \le f(n) \le c_2g(n) \\}$$

> 若存在**正常量**$c_1$和$c_2$，使得对于足够大的$n$，都有$0 \le c_1g(n) \le f(n) \le c_2g(n)$，则$f(n)$属于集合$\Theta(g(n))$，记为$f(n) \subset \Theta(g(n)) $      ($f(n)$是集合$\Theta(g(n))$的一个成员)，为了进行活用，我们简单的记$f(n) = \Theta(g(n)) $。如下图所示$n_0$的值是最小的可能值，同时我们也称$g(n)$是$f(n)$的**渐进紧确界**。

![theta](https://raw.githubusercontent.com/ziyi2/algorithms-javascript/master/img/function-growth/theta.png)

为了使$0 \le c_1g(n) \le f(n) \le c_2g(n)$成立，$\Theta$的定义要求每个成员$f(n) \subset \Theta(g(n)) $均为**渐进非负**。

接下来我们可以举例证明$ { {1\over 2} n^2 - 3n }  =       \Theta(n^2) $：

$$  c_1n^2 \le { {1\over 2} n^2 - 3n } \le c_2n^2 $$
$$  c_1 \le { {1\over 2}  - {3 \over n} } \le c_2 $$

当$n \ge n_0 \ge 1$，且$c_1  = {1\over 2}$时，左边等式恒成立，当$n \ge n_0 \ge 7$时，且$c_2  = {1\over 14}$时，右边等式恒成立，因此当$n \ge n_0 \ge 7$，且$c_1  = {1\over 2}$，$c_2  = {1\over 14}$时可证明$ { {1\over 2} n^2 - 3n }  =       \Theta(n^2) $。

>事实上当n趋于$\infty$时，总有$c_1 \lt {1 \over 2}$且$c_2 \gt {1 \over 2}$时，使得等式成立。因此将$c_1$置为稍小于最高阶系数的值并将$c_2$置为稍大于最高阶项数的值能使$\Theta$记号定义的不等式满足。最高阶系数同样可以被忽略，因为$c_1$和$c_2$都可以根据这个系数进行改变。


注意常量是一个0阶多项式，所以可以将任务常量函数表示为$\Theta(n^0)$或$\Theta(1)$，此后将以$\Theta(1)$表示为一个常量或者关于某个变量的一个常量函数。

### 3. $O$记号

 $\Theta$记号渐进的给出了函数的上界和下界，当只有**渐进上界**时，使用$O$记号，定义如下：

$$ O(g(n)) = \\{ f(n) : 存在常量c和n_0，使得对所有的n \ge n_0，有0 \le f(n) \le cg(n) \\}$$

![theta](https://raw.githubusercontent.com/ziyi2/algorithms-javascript/master/img/function-growth/omicron.png)

> 如上图所示，对于$n_0$右边的所有$n$值，总有$f(n)$小于$cg(n)$。

我们记$O(g(n)) = f(n)$表明$f(n)$是$O(g(n))$集合的成员。同时我们可以发现若$\Theta(g(n)) = f(n)$，那么$O(g(n)) = f(n)$，因为$\Theta$记号是一个比$O$记号范围更广的概念。


我们可以发现在有些文献里经常使用$O$记号来代表$\Theta$记号的含义，事实上$O$记号用来表明$g(n)$的某个常量倍数是$f(n)$的**渐进上界**，而不要求它像$\Theta$记号一样表明是一个**渐进紧确界**。例如对于$O(n^2)$中的$g(n) = n^2$，$f(n) = n^2 = O(n^2)$是**渐进紧确**的，但是$f(n) = n = O(n^2)$却不是。

使用$O$记号来描述算法的运行时间（通过$\Theta$记号和$O$记号的定义我们可以发现，$\Theta$记号对于函数$f(n)$表示的范围更为精确）通常可以指代算法的任何输入的运行时间。例如对于之前的**插入排序**，在之前的描述中最坏情况运行时间为$\Theta(n^2)$，对于已经排好序的输入的运行时间为$\Theta(n)$，如果用$O$记号来描述，我们可以笼统的表明在任何输入情况下，该算法的运行时间为$O(n^2)$（尽管这一描述相对于$\Theta$记号的描述更为模糊）。

> 注意这里不能使用$\Theta$记号描述在任何输入情况下的**插入排序**的运行时间，$O$记号只表明了函数的上界，因此不仅可以指代最坏情况运行时间，还包含了最优情况下$O(n)$运行时间，尽管笼统的描述$O(n^2)$没有体现出来。所以从技术上看，称**插入排序**的运行时间为$O(n^2)$不够精确，有点不合适，因为我们只能描述该算法的最坏情况运行时间，而无法体现最优情况的运行时间。

### 4. $\Omega$记号


 $O$记号渐进的给出了函数的**渐进上界**，$\Omega$记号提供了函数的**渐进下界**，定义如下：


$$ \Omega(g(n)) = \\{ f(n) : 存在常量c和n_0，使得对所有的n \ge n_0，有0 \le  cg(n) \le  f(n) \\}$$


![theta](https://raw.githubusercontent.com/ziyi2/algorithms-javascript/master/img/function-growth/omega.png)

**定理**：对任意两个函数$f(n)$和$g(n)$，我们有$f(n) = \Theta(g(n))$，当且仅当$f(n) = O(g(n))$且$f(n) = \Omega(g(n))$。

利用$\Omega$记号和$O$记号我们可以重新描述**插入排序**的运行时间，在最优情况下运行时间为$\Omega(n)$，而在最坏情况下运行时间为$O(n^2)$。

### 5. 等式中的渐进记号

在$\Theta记号$的描述中，我们记$f(n) \subset \Theta(g(n)) $表示为$f(n) = \Theta(g(n)) $，例如$ { {1\over 2} n^2 - 3n }  =       \Theta(n^2) $，那么$ { {1\over 2} n^2 - \Theta(n) }  =       \Theta(n^2) $如何解释？


这里我们对于渐进记号在公式内的表述做一个更为细致的区分：

- 当渐进记号(不在公式内)独立于等式的另一边时，如$f(n) = \Theta(g(n)) $，我们定义等号**=**指代集合的成员关系：$f(n) \subset \Theta(g(n)) $
- 当渐进记号出现在某个公式中时，我们将其解释为某个不关注名称的匿名函数。例如$ { {1\over 2} n^2 - 3n } = { {1\over 2} n^2 - \Theta(n) }$，意指$ { {1\over 2} n^2 - 3n } = { {1\over 2} n^2 - f(n) }$，其中$f(n) \subset \Theta(n) $。

> 使用第二种情况的渐进记号可以帮助消除一个等式中无关紧要的细节和混乱(例如之前所说的无关紧要的低阶项)。


当然也可以使用渐进记号出现在等式的两边，例如 $ { {1\over 2} n^2 - \Theta(n) } = {  \Theta(n^2) } $，这里可以解释为存在$f(n) \subset \Theta(n) $以及$g(n) \subset \Theta(n^2) $，总有 $ { {1\over 2} n^2 - f(n) } =  g(n) $。


### 6. $\omicron$记号

之前讨论的$O$记号如果把集合的定义范围再缩小，在集合中排除**渐进紧确**的$f(n)$，那么我们可以用$\omicron$记号来定义：

$$ \omicron(g(n)) = \\{ f(n) : 存在常量c和n_0，使得对所有的n \ge n_0，有0 \le f(n) \lt cg(n) \\}$$

例如$n = \omicron(n^2)$，但是$n^2 \neq \omicron(n^2)$，因为存在常数$c$，使得$n^2 \ge cn^2$。直观上当$f(n) = \omicron(g(n))$时，当$n$趋于无穷大时，$f(n)$相对于$g(n)$几乎可以省略：

$$\lim\limits_{n \to \infty }{f(n) \over g(n)}  =  0$$

即如果在分析算法运行时间的时候，$f(n)$就是经常被忽略的低阶项。


### 7. $\omega $记号

和$\omicron$记号相对应， $\omega$记号标识一个非渐进紧确的下界，定义为：

$$ \omega(g(n)) = \\{ f(n) : 存在常量c和n_0，使得对所有的n \ge n_0，有0 \le  cg(n) \lt  f(n) \\}$$

例如$n^3 = \omega (n^2)$，但是$n^2 \neq \omega (n^2)$，当$n$趋于无穷大时:

$$\lim\limits_{n \to \infty }{f(n) \over g(n)}  =  \infty $$


### 8. 记号的特性

假定$f(n)$和$g(n)$渐进为正，则存在如下特性：

**传递性**


$f(n) = \Theta(g(n)) $且$g(n) = \Theta(h(n)) $，那么$f(n) = \Theta(h(n)) $

> 上述所讲的记号都成立。

**自反性**

$f(n) = \Theta(f(n)) $

$f(n) = O(f(n)) $

$f(n) = \Omega(f(n)) $

**对称性**

$f(n) = \Theta(g(n)) $ 当且仅当 $g(n) = \Theta(f(n)) $

**转置对称性**


$f(n) = O(g(n)) $ 当且仅当 $g(n) = \Omega(f(n)) $

$f(n) = \omicron(g(n)) $ 当且仅当 $g(n) = \omega(f(n)) $



### 9. 小结

对于以上描述的记号，其实和实数的$\lt、\gt、\le、\ge以及=$比较类似，区别在于记号的比较是函数之间的比较，而实数的比较纯粹就是比较大小，我们可以使用实数的关系来刻画记号的特性，例如存在实数$a和b$，那么记号和实数比较的类似关系如下：


$f(n) = \Theta(g(n)) $          类似于   $a=b$

$f(n) =  O(g(n)) $          类似于   $a \le b$

$f(n) =  \Omega(g(n)) $          类似于   $a \ge b$

$f(n) =  \omicron(g(n)) $          类似于   $a \lt b$

$f(n) =  \omega(g(n)) $          类似于   $a \gt b$

需要注意的是实数必定存在以上$\lt、\gt、\le、\ge以及=$关系，但是函数不一定，例如震荡函数。
