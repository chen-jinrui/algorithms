## 归并排序

[插入排序](https://github.com/ziyi2/algorithms-javascript/blob/master/doc/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.md)采用的是**增量**方法解决排序问题（将待排序的数插入到已排序好的数组中），**归并排序**则采用**分治法**设计，**分支法**的有点是最差运行时间比**插入排序**要少得多，同时该方法更容易确定算法的运行时间。

### 分治法

将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，最终合并这些子问题的解来建立原问题的解。分治法在每层递归时都有三个步骤：
- **分解**：分解原问题为若干个子问题，这些子问题是原问题规模较小的一个实例。
- **解决**：递归求解这些子问题。如果问题的规模足够小，则直接求解。
- **合并**：合并子问题的解成原问题的解。

### 算法说明

**归并排序**采用**分治法**进行设计，因此也有三个步骤：
- **分解**：将$n$个待排序的元素组成的数组分解成各具$n \over 2$个元素的两个子数组（左右子数组）。
- **解决**：使用归并排序递归的排序左右两个子数组。
- **合并**：合并两个已排序的子数组以产生排序后的数组。

![插入排序](https://raw.githubusercontent.com/ziyi2/algorithms-javascript/master/img/merge-sort_1.gif)


**分解**的`javascript`实现如下：

``` javascript
function merge(arr, leftStart, leftEnd, rightEnd) {
  // 计算左子数组的长度
  let leftNum = leftEnd - leftStart + 1,
      // 计算右子数组的长度
      rightNum = rightEnd - leftEnd,
      lefts = [],
      rights = [],
      i,j
	
  // 赋值左子数组	
  for(i=0; i<leftNum; i++) {
    lefts[i] = arr[leftStart+i]
  }
  
  // 赋值右子数组
  for(j=0; j<rightNum; j++) {
    rights[j] = arr[leftEnd+1+j]
  }

  // 哨兵值，一旦只剩下哨兵值则表明当前数组中的元素已经排序完成
  lefts[i++] = Infinity
  rights[j++] = Infinity

  i = 0
  j = 0

  // 将左右子数组中的元素按从小到大重新插入数组arr
  for(let k=leftStart; k<=rightEnd; k++) {
    if(lefts[i] <= rights[j]) {
      arr[k] = lefts[i]
      i++
    } else {
      arr[k] = rights[j]
      j++
    }
  }
}
```
> 在左右子数组（前提是已经排好序）末尾各加入了一个$\infty$值，用于简化代码，一旦某个数组中的元素全部排序完毕，那么通过该$\infty$值的判断（未排序完毕数组中的剩余元素始终小于无穷大$\infty$）从而可以将未排序完的元素全部插入已排序元素的末尾。

