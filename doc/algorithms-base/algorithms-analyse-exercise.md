### 分析算法习题

#### `问题1`

***

用$\theta$记号表示函数${n^3 \over 1000} - 100n^2 - 100n + 3 $。

#### `答案`
$\theta(n^3)$


#### `问题2`

***

考虑排序存储在A中的n个数：首先找出A中的最小元素并将其与A[1]中的元素进行交换。接着，找出A中的次最小元素并将其与A[2]进行交换。对A中前n-1个元素按该方式继续。该算法称为**选择算法**，写出其伪代码。该算法维持的循环不变式是什么？为什么它只需要对前n-1个元素，而不是对所有n个元素运行？用$\theta$记号给出选择排序的最好运行时间和最差情况运行时间。


#### `答案`

``` javascript
function selectionSort(arr) {
  let array = [...arr],
      length = array.length,
      minIndex,
      template

  // 这里最后一个元素不需要再排序
  for(let i=0; i<length-1; i++) {

    minIndex = i
    
    for(let j=i+1; j<length; j++) {
      if(array[minIndex] < array[j]) continue
      minIndex = j
    }

    template = array[i]
    array[i] = array[minIndex]
    array[minIndex] = template
  }

  return array
}
```

**循环不变式：**在外部`for循环`开始之前的子数组`array[0]~array[i-1]`由数组`array[0]~array[n]`中的`i-1`个最小元素组成，并且这些元素已经排好序，因此`array[0]~array[i-1]`是循环不变式。

注释代码所在的循环并没有将最后一个元素包括在内，是因为当循环到`n-1`个元素的时候，`array[0]~array[n-1]`是`n`个元素中的`n-1`个最小元素组成，因此第`n`个元素就是最大的元素，不需要进行数组的任何操作。

跟**插入排序**不同，**选择排序**不管在最佳情况下还是最坏情况下获取剩余数组的最小元素都需要进行完全遍历，没有任何循环只需要执行一次的情况，因此运行时间都是$\theta(n^2)$。


#### `问题3`

***

应如何修改任何一个算法，才能使之具有良好的最佳情况运行时间。

#### `答案`

算法开始检测输入数据，若符合特殊条件则输出事先计算好的结果。例如只排序只有一个元素数组的情况下，可以直接输出该数组。