### 算法基础思考题


#### `思考题1`

***

**（在归并排序中对小数组采用插入排序）**虽然归并排序的最坏情况运行时间为$\theta(nlgn)$，而插入排序的最坏情况运行时间为$\theta(n^2)$，但是插入排序中的常量因子可能使得它在$n$较小时，在许多机器上实际运行得更快。因此，在归并排序中当子问题变得足够小时，采用插入排序来使递归的叶变粗是有意义的。考虑对归并排序的一种修改，其中使用插入排序来排序长度为k的n/k个子表，然后使用标准的合并机制来合并这些子表，这里k是一个待定的值。

a.证明：插入排序最坏情况可以在$\theta(nk)$时间内排序每个长度为$k$的$n/k$个子表。

b.表明在最坏情况下如何在$\theta(nlg(n/k))$时间内合并这些子表。

c.假定修改后的算法的最坏情况运行时间为$\theta(nk+nlg(n/k))$，要使修改后的算法与标准的归并排序具有相同的运行时间，作为$n$的一个函数，借助$\theta$记号，$k$的最大值是什么？

d.在实践中，我们应该如何选择$k$？



#### `思考题2`

***

**（冒泡排序算法的正确性）**冒泡排序(bubblesort)算法是一种流行的排序算法，它重复地交换相邻两个反序元素。

``` javascript
BUBBLESORT(A)
for i=1 to length[A] -1
    for j=length[A] downto i+1
        if A[j]< A[j-1]
           exchange A[j]←→ A[j-1]
```

a) 设A’表示BULLESORT(A)的输出，为了证明BUBBLESORT是正确的，需要证明它能够终止，并且有：

 A’[1]<=A[2]<=..<=A’[n]
 
其中n=length[A]。为了证明BUBBLESORT的确能实现排序的效果，还需要证明什么？
下面两个部分将证明不等式（2.3）。

b) 对第2~4行中的for循环，给出一个准确的循环不变式，并证明该循环不变式是成立的。在证明中采用本章中给出的循环不变式证明结构。

c) 利用在b）部分证明的循环不变式的终止条件，为第1~4行中的for循环给出一个循环不变式，它可以用来证明不等式（2.3）。你的证明因采用本章中给出的循环不变式的证明结构。

d) 冒泡排序算法的最坏情况运行时间是什么？比较它与插入排序的运行时间。




